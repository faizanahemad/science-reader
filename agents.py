from typing import Union, List

from base import CallLLm, CallMultipleLLM
from common import get_async_future, sleep_and_get_future_result
from loggers import getLoggers
import logging
logger, time_logger, error_logger, success_logger, log_memory_usage = getLoggers(__name__, logging.WARNING, logging.INFO, logging.ERROR, logging.INFO)
import time
agents = []
adl = []
adllib = []
agent_language_parser = []

class Agent:
    def __init__(self, keys):
        self.keys = keys

    def __call__(self, text, images=[], temperature=0.7, stream=False, max_tokens=None, system=None, web_search=False):
        pass

class WebSearchWithTopicBreakdownAgent(Agent):
    def __init__(self, keys, model_name, detail_level=2, timeout=10):
        super().__init__(keys)

    def __call__(self, text, images=[], temperature=0.7, stream=False, max_tokens=None, system=None, web_search=True):
        # Break down topics in the text
        # One search query for each topic of interest
        # Search for each query
        # RAG response of each query using LLM.
        pass


class ReflectionAgent(Agent):
    def __init__(self, keys, writer_model: Union[List[str], str], improve_model: str, outline_model: str):
        self.keys = keys
        self.writer_model = writer_model
        self.improve_model = improve_model
        self.outline_model = outline_model
        self.system = """
As an AI language model assistant, your task is to enhance a simple answer provided for a user's query by performing self-reflection and objective analysis.
Answer comprehensively in detail like a PhD scholar and leading experienced expert in the field. Compose a clear, detailed, comprehensive, thoughtful and highly informative response.
We need to help people with hand, wrist disability and minimise typing and editing on their side. Deduce what the question or query is asking about and then go above and beyond to provide a high quality response. Write full answers.
Answer completely in a way that our work can be used by others directly without any further editing or modifications. We need to be detail oriented, cover all references and provide details, work hard and provide our best effort. 
        """.strip()
        self.prompt = f"""
As an AI language model assistant, your task is to enhance a simple answer provided for a user's query by performing self-reflection and objective analysis. 
You will be given:  
- A **User Query**  and some context around it if necessary.
- One or more **Simple Expert Answers** generated by one or more AI models.
- Some guidance on how to write a good answer from another LLM model. You may optionally use this guidance to further help your reflection and thinking steps.
  
Follow the steps outlined below, using the specified XML-style tags to structure your response. This format will help in parsing and reviewing each part of your process.  

---  
## Instructions:  
1. **Identify the Primary Goals:**  
   - Carefully read and understand the user's query.  
   - Determine the main objectives and what the user is seeking.  
   - Determine how we can go above and beyond to provide a high-quality response and help the user effectively.
   - Enclose your findings within `<primary_goals>` and `</primary_goals>` tags.  
  
2. **Reflect on the Simple Answer:**  
   - Analyze the simple expert answers provided.  
   - If more than one simple answer is provided by different models, consider each one and pick the best parts and aspects from each.
   - For more than one simple expert answer, you can compare and contrast them to identify the strengths and weaknesses of each and then use a combination of them before improving them.
   - Assess how it can be improved to better meet the user's needs.  
   - Identify any missing information, corner cases, or important considerations.  
   - Enclose your reflection within `<reflection>` and `</reflection>` tags.  
  
3. **Think Logically and Step by Step:**  
   - Outline your thought process for improving the answer.  
   - Provide a logical, step-by-step explanation of enhancements.  
   - Enclose your reasoning within `<thinking>` and `</thinking>` tags.  
   
4. **Recheck and Revise your reflection and thinking to make sure they are correct:**
    - Review your reflection and thinking to ensure they are accurate and logical.
    - Revise them if necessary.
    - Check if you are using the best aspects of each simple answer to improve the final answer.
    - Check if you are addressing all the user's needs and concerns.
    - Check if you are overall improving the answer in a meaningful way and also maintaining good structure and format.
    - Enclose your revised reflection within `<revised_reflection>` and `</revised_reflection>` tags.
    - Enclose your revised thinking within `<revised_thinking>` and `</revised_thinking>` tags. 
    - The `<recheck_and_revise>` tag wraps both the `<revised_reflection>` and `<revised_thinking>` sections to keep revisions organized.  
    - If no revisions are needed, you can state that no changes were necessary in these sections inside `<recheck_and_revise>` tags.
  
5. **Provide the Improved Answer:**  
   - Compose a new, comprehensive answer that addresses all aspects of the user's query.  
   - Incorporate all improvements identified in your reflection.  
   - Mention the improvements you are making specifically compared to the original answer inside the `<improvements>` and `</improvements>` tags.
   - Ensure clarity, accuracy, and usefulness.  
   - Provide any and all details from the simple expert answers we already have in our final answer.
   - Enclose the final answer within `<answer>` and `</answer>` tags.  
  
---  
**Formatting Guidelines:**  
- Use the following XML-style tags to structure your response:  
  - `<primary_goals>` ... `</primary_goals>`  
  - `<reflection>` ... `</reflection>`  
  - `<thinking>` ... `</thinking>`  
  - `<revised_reflection>` ... `</revised_reflection>`
  - `<revised_thinking>` ... `</revised_thinking>`
  - `<improvements>` ... `</improvements>`
  - `<answer>` ... `</answer>`

User Query with context:
<user_query>
{{query}}
</user_query>

<optional_guidance>
{{guidance}}
</optional_guidance>

Simple Answers:
<simple_answers>
{{simple_answer}}
</simple_answers>

Now your overall response would look and be formatted like this:
<primary_goals>
    [Identify the user's main objectives.]  
</primary_goals>
<reflection>
    [Reflect on the simple answer and identify areas of improvement.]  
</reflection>
<thinking>
    [Provide a step-by-step plan for enhancements.]  
</thinking>
<recheck_and_revise>  
    <revised_reflection>  
        [Revise your reflection if needed.]  
    </revised_reflection>  
    <revised_thinking>  
        [Revise your thinking if needed.]  
    </revised_thinking>  
</recheck_and_revise>  
<improvements>
    [Detail the specific improvements over the simple answer.]  
</improvements>
<answer>
    [Provide the improved answer to the user's query.] 
</answer>

If we have multiple simple answers, we include all ideas, insights, and improvements from each simple answer in our final answer. 
Use good organization, formatting and structure in your response. 
Use simple markdown formatting and indentation for appealing and clear presentation. For markdown formatting use 2nd level or lower level headers (##) and lower headers for different sections. Basically use small size headers only.
Now respond to the user's query and enhance the simple answer provided in the above format.
""".lstrip()
        self.good_answer_characteristics_prompt = f"""
Your task is to write down the characteristics of a good answer. You must mention how a good answer should be structured and formatted, what it should contain, and how it should be presented.
You will be given:  
- A **User Query**  and some context around it if necessary.

Based on the user query and the context provided, write down the characteristics of a good answer. 
You must mention 
- what topics a good answer to the user query must contain, 
- how it should be structured, 
- what areas it must cover, 
- what information it should provide,
- what details it should include,
- what are some nuances that should be considered,
- If the query is about a specific topic, what are some key points that should be included,
- If the query is a trivia, logic question, science question, math question, coding or other type of logical question then what are some high level steps and skills that are needed to solve the question, 
- what are some Aha stuff and gotchas that should be included,
- what are some corner cases that should be addressed,
- how can we make the answer more informative and useful, engaging and interesting, stimulating and thought-provoking,
- how can we make the answer more comprehensive and detailed,
- how can we make the answer more accurate and correct and useful and implementable if needed,
- what parts of the answer, topics, areas, and details should be dived deeper into and emphasized, 
- how it should be formatted,
- and how it should be presented.
- You can also mention what are some common mistakes that should be avoided in the answer and what are some common pitfalls that should be addressed.
- Write a detailed and comprehensive outline of the answer that should be provided to the user.

User Query with context:
<user_query>
{{query}}
</user_query>

Write down the characteristics of a good answer in detail following the above guidelines and adding any additional information you think is relevant.
""".strip()
        self.first_model = CallLLm(keys, self.writer_model) if isinstance(self.writer_model, str) else CallMultipleLLM(keys, self.writer_model)
        self.improve_model = CallLLm(keys, self.improve_model)
        self.outline_model = CallLLm(keys, self.outline_model) if isinstance(self.outline_model, str) else CallLLm(keys, self.improve_model)

    def __call__(self, text, images=[], temperature=0.7, stream=False, max_tokens=None, system=None, web_search=False):
        st = time.time()
        # outline_future = get_async_future(self.outline_model, self.good_answer_characteristics_prompt.format(query=text), images, temperature, False, max_tokens, system)
        first_response = self.first_model(text, images, temperature, False, max_tokens, system)
        time_logger.info(f"Time taken to get multi model response: {time.time() - st} with response length: {len(first_response.split())}")
        # outline = sleep_and_get_future_result(outline_future)
        # time_logger.info(f"Time taken to get till outline: {time.time() - st} with outline length: {len(outline.split())}")
        outline = ""
        improve_prompt = self.prompt.format(query=text, simple_answer=first_response, guidance=outline)
        if system is None:
            system = self.system
        else:
            system = f"{self.system}\n{system}"

        improved_response = self.improve_model(improve_prompt, images, temperature, False, max_tokens, system)
        time_logger.info(f"Time taken to get improved response: {time.time() - st}")
        # Now lets parse the response and return the improved response
        primary_goals = improved_response.split('</primary_goals>')[0].split('<primary_goals>')[-1]
        reflection = improved_response.split('</reflection>')[0].split('<reflection>')[-1]
        thinking = improved_response.split('</thinking>')[0].split('<thinking>')[-1]
        revised_reflection = improved_response.split('</revised_reflection>')[0].split('<revised_reflection>')[-1]
        revised_thinking = improved_response.split('</revised_thinking>')[0].split('<revised_thinking>')[-1]
        improvements = improved_response.split('</improvements>')[0].split('<improvements>')[-1]
        answer = improved_response.split('</answer>')[0].split('<answer>')[-1]
        # return a dictionary
        return {
            'primary_goals': primary_goals,
            'reflection': reflection,
            'thinking': thinking,
            'revised_reflection': revised_reflection,
            'revised_thinking': revised_thinking,
            'improvements': improvements,
            'answer': answer
        }


class IdeaEvalAgent(Agent):
    def __init__(self):
        pass

    def __call__(self, prompt, web_search=False):
        pass

class IdeaCompareAgent(Agent):
    def __init__(self):
        pass

    def __call__(self, prompt, web_search=False):
        pass

class IdeasRankingAgent(Agent):
    def __init__(self):
        pass

    def __call__(self, prompt, web_search=False):
        pass

