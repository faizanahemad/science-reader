"""
Database helpers for extension custom scripts.

Provides CRUD operations for the ``CustomScripts`` table in ``users.db``.
Ported from ``extension.py`` ExtensionDB script methods to run on the main
backend so the Chrome extension can manage scripts without a separate server.

Table lives in ``users.db`` alongside other user-scoped data.  The table is
created by ``database.connection.create_tables()`` on server startup.
"""

from __future__ import annotations

import fnmatch
import json
import logging
import os
import re
import secrets
from datetime import datetime
from sqlite3 import Error
from typing import Any, Dict, List, Optional

from database.connection import create_connection

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Row → dict conversion
# ---------------------------------------------------------------------------

_SCRIPT_COLUMNS = (
    "script_id",
    "user_email",
    "name",
    "description",
    "script_type",
    "match_patterns",
    "match_type",
    "code",
    "actions",
    "enabled",
    "version",
    "conversation_id",
    "created_with_llm",
    "created_at",
    "updated_at",
)


def _row_to_dict(row: tuple) -> Dict[str, Any]:
    """Convert a raw DB row (15-tuple) to a typed script dict."""
    return {
        "script_id": row[0],
        "user_email": row[1],
        "name": row[2],
        "description": row[3],
        "script_type": row[4],
        "match_patterns": json.loads(row[5]) if row[5] else [],
        "match_type": row[6],
        "code": row[7],
        "actions": json.loads(row[8]) if row[8] else [],
        "enabled": bool(row[9]),
        "version": row[10],
        "conversation_id": row[11],
        "created_with_llm": bool(row[12]),
        "created_at": row[13],
        "updated_at": row[14],
    }


_SELECT_COLS = ", ".join(_SCRIPT_COLUMNS)

# Fields the update endpoint may touch.
_ALLOWED_UPDATE_FIELDS = {
    "name",
    "description",
    "script_type",
    "match_patterns",
    "match_type",
    "code",
    "actions",
    "enabled",
    "conversation_id",
}


# ---------------------------------------------------------------------------
# DB helper class
# ---------------------------------------------------------------------------


class ExtScriptsDB:
    """
    CRUD helper for the ``CustomScripts`` table.

    Parameters
    ----------
    db_path : str
        Absolute path to ``users.db``.
    """

    def __init__(self, db_path: str) -> None:
        self.db_path = db_path

    # -- helpers --

    def _conn(self):
        return create_connection(self.db_path)

    # -- CRUD --

    def create_custom_script(
        self,
        user_email: str,
        name: str,
        match_patterns: List[str],
        code: str,
        description: Optional[str] = None,
        script_type: str = "functional",
        match_type: str = "glob",
        actions: Optional[List[Dict]] = None,
        conversation_id: Optional[str] = None,
        created_with_llm: bool = True,
    ) -> Dict[str, Any]:
        """
        Create a new custom script.

        Parameters
        ----------
        user_email : str
            Owner's email.
        name : str
            Human-readable script name.
        match_patterns : list[str]
            URL patterns (glob or regex).
        code : str
            JavaScript source code.
        description : str, optional
        script_type : str
            ``'functional'`` (default) or ``'parsing'``.
        match_type : str
            ``'glob'`` (default) or ``'regex'``.
        actions : list[dict], optional
            Action definitions for functional scripts.
        conversation_id : str, optional
            Link back to the conversation where the script was created.
        created_with_llm : bool
            Whether the script was generated by an LLM.

        Returns
        -------
        dict
            The newly created script record.
        """
        conn = self._conn()
        cursor = conn.cursor()
        script_id = secrets.token_hex(16)
        now = datetime.utcnow().isoformat()

        try:
            cursor.execute(
                """
                INSERT INTO CustomScripts
                (script_id, user_email, name, description, script_type,
                 match_patterns, match_type, code, actions, enabled,
                 version, conversation_id, created_with_llm, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    script_id,
                    user_email,
                    name,
                    description,
                    script_type,
                    json.dumps(match_patterns),
                    match_type,
                    code,
                    json.dumps(actions) if actions else None,
                    1,  # enabled
                    1,  # version
                    conversation_id,
                    1 if created_with_llm else 0,
                    now,
                    now,
                ),
            )
            conn.commit()

            return {
                "script_id": script_id,
                "user_email": user_email,
                "name": name,
                "description": description,
                "script_type": script_type,
                "match_patterns": match_patterns,
                "match_type": match_type,
                "code": code,
                "actions": actions or [],
                "enabled": True,
                "version": 1,
                "conversation_id": conversation_id,
                "created_with_llm": created_with_llm,
                "created_at": now,
                "updated_at": now,
            }
        except Error as e:
            raise RuntimeError(f"Failed to create script: {e}") from e
        finally:
            conn.close()

    def get_custom_script(
        self, user_email: str, script_id: str
    ) -> Optional[Dict[str, Any]]:
        """
        Get a single script by ID (scoped to user).

        Parameters
        ----------
        user_email : str
        script_id : str

        Returns
        -------
        dict or None
        """
        conn = self._conn()
        cursor = conn.cursor()
        try:
            cursor.execute(
                f"SELECT {_SELECT_COLS} FROM CustomScripts "
                "WHERE script_id = ? AND user_email = ?",
                (script_id, user_email),
            )
            row = cursor.fetchone()
            return _row_to_dict(row) if row else None
        except Error as e:
            raise RuntimeError(f"Failed to get script: {e}") from e
        finally:
            conn.close()

    def get_custom_scripts(
        self,
        user_email: str,
        enabled_only: bool = False,
        script_type: Optional[str] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[Dict[str, Any]]:
        """
        List scripts for a user with optional filters.

        Parameters
        ----------
        user_email : str
        enabled_only : bool
        script_type : str, optional
            ``'functional'`` or ``'parsing'``.
        limit : int
        offset : int

        Returns
        -------
        list[dict]
        """
        conn = self._conn()
        cursor = conn.cursor()
        try:
            query = f"SELECT {_SELECT_COLS} FROM CustomScripts WHERE user_email = ?"
            params: list = [user_email]

            if enabled_only:
                query += " AND enabled = 1"
            if script_type:
                query += " AND script_type = ?"
                params.append(script_type)

            query += " ORDER BY updated_at DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

            cursor.execute(query, params)
            return [_row_to_dict(row) for row in cursor.fetchall()]
        except Error as e:
            raise RuntimeError(f"Failed to list scripts: {e}") from e
        finally:
            conn.close()

    def update_custom_script(
        self, user_email: str, script_id: str, **updates: Any
    ) -> bool:
        """
        Update allowed fields on a script.

        Automatically increments ``version`` and sets ``updated_at``.

        Parameters
        ----------
        user_email : str
        script_id : str
        **updates
            Field-value pairs.  Only keys in ``_ALLOWED_UPDATE_FIELDS`` are
            applied; others are silently ignored.

        Returns
        -------
        bool
            True if a row was actually updated.
        """
        valid = {k: v for k, v in updates.items() if k in _ALLOWED_UPDATE_FIELDS}
        if not valid:
            return False

        # Serialise complex types
        if "match_patterns" in valid:
            valid["match_patterns"] = json.dumps(valid["match_patterns"])
        if "actions" in valid:
            valid["actions"] = json.dumps(valid["actions"])
        if "enabled" in valid:
            valid["enabled"] = 1 if valid["enabled"] else 0

        conn = self._conn()
        cursor = conn.cursor()
        try:
            set_clause = ", ".join(f"{k} = ?" for k in valid)
            values = list(valid.values())
            now = datetime.utcnow().isoformat()
            values.extend([now, script_id, user_email])

            cursor.execute(
                f"UPDATE CustomScripts "
                f"SET {set_clause}, version = version + 1, updated_at = ? "
                "WHERE script_id = ? AND user_email = ?",
                values,
            )
            conn.commit()
            return cursor.rowcount > 0
        except Error as e:
            raise RuntimeError(f"Failed to update script: {e}") from e
        finally:
            conn.close()

    def delete_custom_script(self, user_email: str, script_id: str) -> bool:
        """
        Delete a script.

        Parameters
        ----------
        user_email : str
        script_id : str

        Returns
        -------
        bool
            True if a row was deleted.
        """
        conn = self._conn()
        cursor = conn.cursor()
        try:
            cursor.execute(
                "DELETE FROM CustomScripts WHERE script_id = ? AND user_email = ?",
                (script_id, user_email),
            )
            conn.commit()
            return cursor.rowcount > 0
        except Error as e:
            raise RuntimeError(f"Failed to delete script: {e}") from e
        finally:
            conn.close()

    def get_scripts_for_url(self, user_email: str, url: str) -> List[Dict[str, Any]]:
        """
        Return all enabled scripts whose ``match_patterns`` match *url*.

        Supports both glob (``*`` wildcards, default) and regex patterns.

        Parameters
        ----------
        user_email : str
        url : str
            Full URL to match against.

        Returns
        -------
        list[dict]
        """
        conn = self._conn()
        cursor = conn.cursor()
        try:
            cursor.execute(
                f"SELECT {_SELECT_COLS} FROM CustomScripts "
                "WHERE user_email = ? AND enabled = 1",
                (user_email,),
            )

            matching: List[Dict[str, Any]] = []
            for row in cursor.fetchall():
                patterns = json.loads(row[5]) if row[5] else []
                match_type = row[6] or "glob"
                matched = False

                for pattern in patterns:
                    try:
                        if match_type == "regex":
                            if re.match(pattern, url):
                                matched = True
                                break
                        else:
                            # Glob → regex: escape dots, convert * to .*
                            regex_pat = pattern.replace(".", r"\.")
                            regex_pat = regex_pat.replace("*", ".*")
                            regex_pat = f"^{regex_pat}$"
                            if re.match(regex_pat, url):
                                matched = True
                                break
                    except re.error:
                        continue

                if matched:
                    matching.append(_row_to_dict(row))

            return matching
        except Error as e:
            raise RuntimeError(f"Failed to get scripts for URL: {e}") from e
        finally:
            conn.close()


# ---------------------------------------------------------------------------
# Module-level convenience
# ---------------------------------------------------------------------------


def get_ext_scripts_db() -> ExtScriptsDB:
    """
    Return an ``ExtScriptsDB`` pointing at the main backend's ``users.db``.
    """
    from endpoints.state import get_state

    state = get_state()
    db_path = os.path.join(state.users_dir, "users.db")
    return ExtScriptsDB(db_path)
